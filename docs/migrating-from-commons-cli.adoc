= Migrating from Commons CLI to picocli

Commons CLI, initially released in 2002, is perhaps the most widely used java command line parser, but its API shows its age.
Applications looking for a modern approach with a minimum of boilerplate code may be interested in picocli. Picocli offers a fluent API with strong typing, usage help with ANSI colors, autocompletion and a host of other features. Why is it worth the trouble to migrate, and how do you migrate your Commons CLI-based application to picocli? Let's take a look using http://checkstyle.sourceforge.net[Checkstyle] as an example.


== Why Migrate?
Is migrating from Commons CLI to picocli worth the trouble? What is the benefit of moving from one command line parser to another? Isn't that just redecorating the living room of our application?


=== End User Experience

image:https://3g3qeh2v2xw32ifq4r3x9gj7-wpengine.netdna-ssl.com/wp-content/uploads/2018/07/pexels-photo-1210532.jpeg[width=200]

What are the benefits for the end user?

First, *@-files*, or https://picocli.info/#AtFiles["argument files"]. Sometimes users need to specify command lines that are longer than supported by the operating system or the shell. When picocli encounters an argument beginning with the character `@`, it expands the contents of that file into the argument list.

Nice-looking *usage help* message. The usage help generated by Commons CLI is a bit minimalistic. Out of the box, picocli generates good-looking help with ANSI colors. Additionally, the help message layout is easy to customize. Most of the time the annotations provide enough control over the usage help layout, but there is also a Help API in case you want something different. See the picocli https://github.com/remkop/picocli[README] for some example screenshots.

*Troubleshooting*. Picocli has a built-in https://picocli.info/#_tracing[tracing] facility to facilitate troubleshooting. End users can use system property `picocli.trace` to control the trace level. Supported levels are `OFF`, `WARN`, `INFO`, and `DEBUG`. The default trace level is `WARN`. Specifying system property `-Dpicocli.trace` without a value will set the trace level to `INFO`.

=== Developer Experience
image:https://static1.squarespace.com/static/5a75d0d1d74cff3a9efea1c3/t/5a8c4fb153450ac8657fad03/1519144904584/1_ipf30KJppLZ_Godcq82R3Q.png[width=200]
_Photo by https://www.pexels.com/u/nurseryart/[Porapak Apichodilok]_

What are the benefits for you as developer?

Generally a picocli application will have a lot *less code* than the Commons CLI equivalent. The picocli annotations allow applications to define options and positional parameters in a *declarative* way where all information is in one place. Also, picocli offers a number of *conveniences* like type conversion and automatic help that take care of some mechanics so the application can focus more on the business logic. The rest of this article will show this in more detail.

*Documentation*: picocli has an extensive https://picocli.info[user manual] and detailed https://picocli.info/apidocs/[javadoc].

Fewer small annoyances:

* The default parser in Commons CLI recognizes long options with a single `-` hyphen even if its usage help message only shows long options with two `--` dashes. I did not see a way to prevent this. By contrast, picocli gives fine-grained and exact control over the option prefix.
* It is surprisingly difficult in Commons CLI to create an application with a required option that also has a `--help` option. Commons CLI has no special treatment for help options and will complain about the missing required option when the user specifies `<command> --help`. Picocli has built-in support for common (and custom) help options.

=== Future Expansion
image:https://cdn.psychologytoday.com/sites/default/files/styles/image-article_inline_full/public/field_blog_entry_images/2017-08/seeing-the-future.jpg[width=200]

Finally, other than the immediate pay-off, are there any future benefits to be gained by migrating from Commons CLI to picocli?

Picocli has a lot of *advanced features*. Your application may not use these features yet, but if you want to expand your application in the future, picocli has support for nested https://picocli.info/#_subcommands[subcommands] (and sub-subcommands to any depth), can easily integrate with Dependency Injection frameworks, and has tools to generate completion scripts to give your application https://picocli.info/autocomplete.html[command line completion] in bash and zsh shells.

Finally, picocli is *actively maintained*, whereas Commons CLI seems to be near-dormant with 4 releases in 16 years.

== An Example Migration: CheckStyle
The CheckStyle project was interested in migrating from Commons CLI to get cleaner code, and provide end users with a better experience. The rest of this article uses the CheckStyle command line utility to demonstrate what the code looks like before and after migrating to picocli.


image:https://picocli.info/images/checkstyle-logo-260x50.png[width=200]

//image:https://www.insuremypath.org/sites/default/files/styles/490x350/public/2018-03/pexels-photo-704767.jpeg?itok=lAiP3j-p[width=200]


A command line application needs to do three things:

. Define the supported options
. Parse the command line arguments
. Process the results:
  - Was version help or usage help requested? If so, print out the requested information and quit.
  - Validate the user input. If invalid, print an error message and quit.
  - Finally, run the business logic of the application, based on the values specified by the user.

Let's go over these and compare how this is done in Commond CLI and in picocli, using CheckStyle's command line utility as an example. The resulting source code after the migration can be found here: https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/Main.java[`com.puppycrawl.tools.checkstyle.Main`].

=== Defining Options and Positional Parameters

image:images/pexels-photo-97077.jpeg[width=200]

// image:https://greenbookblog.org/wp-content/uploads/2018/02/pexels-photo-533189-768x576.jpeg[width=200]

==== Commons CLI Example
Commons CLI has multiple ways to define options: `Options.addOption`, calling `new Options(...)` and invoking setter methods on this object, the deprecated `OptionBuilder` class, and the recommended `Option.Builder` class.

The Checkstyle `Main` class uses the `Options.addOption` method. It starts by defining a number of constants for the option names:

[source,java]
----
/** Name for the option 's'. */
private static final String OPTION_S_NAME = "s";

/** Name for the option 't'. */
private static final String OPTION_T_NAME = "t";

/** Name for the option '--tree'. */
private static final String OPTION_TREE_NAME = "tree";

... // and more. Checkstyle Main has 26 options in total.
----
The `Main.buildOptions` method uses these constants to construct and return a Commons CLI `Options` object that defines the supported options:
[source,java]
----
private static Options buildOptions() {
    final Options options = new Options();
    options.addOption(OPTION_C_NAME, true, "Sets the check configuration file to use.");
    options.addOption(OPTION_O_NAME, true, "Sets the output file. Defaults to stdout");
    ...
    options.addOption(OPTION_V_NAME, false, "Print product version and exit");
    options.addOption(OPTION_T_NAME, OPTION_TREE_NAME, false,
            "Print Abstract Syntax Tree(AST) of the file");
    ...
    return options;
}
----

==== Picocli Example

In picocli you can define supported options either programmatically with builders, similar to the Commons CLI approach, or declaratively with annotations.

The annotations style (example follows below), is likely the preferred option for most applications because it is more declarative and results in less code. Picocli also offers a programmatic API, which may be useful for dynamic applications where not all options are known in advance. If you're interested in the programmatic approach, take a look at the the `CommandSpec`, `OptionSpec` and `PositionalParamSpec` classes. See also https://github.com/remkop/picocli/wiki/Programmatic-API[Programmatic API] for more detail.

In this article we will use the picocli annotations. For the CheckStyle example, this would look something like the below:

[source,java]
----
@Option(names = "-c", description = "Sets the check configuration file to use.")
File configurationFile;

@Option(names = "-o", description = "Sets the output file. Defaults to stdout")
File outputFile;

@Option(names = "-v", versionHelp = true, description = "Print product version and exit")
boolean versionHelpRequested;

@Option(names = {"-t", "--tree"}, description = "Print Abstract Syntax Tree(AST) of the file")
boolean printAST;
----

==== Declarative

image:https://picocli.info/images/declare.jpg[width=200]

You immediately note a few things. First, all information is now in one place.

With Commons CLI, you build a specification by calling a method with String values. One drawback of a Commons CLI-like API is that good style compels client code to define constants to avoid "magic values", like the Checkstyle `Main` class dutifully does. Annotations only accept String literals, so definition and usage are automatically placed together without the need to declare constants. In this case, that arguably results in cleaner code.

==== Types

image::https://picocli.info/images/Type.jpg[width=200]

Another thing that is interesting is that we went from using `true` or `false` in Commons CLI to denote whether the option takes an argument or not:

[source,java]
----
// declaring an option with Commons CLI
final Options options = new Options();
options.addOption(OPTION_C_NAME, true, "Sets the check configuration file to use.");
----

to declaring fields with types in picocli:

[source,java]
----
// declaring an option with picocli
@Option(names = "-c", description = "Sets the check configuration file to use.")
File configurationFile;
----

This has a number of advantages:

* automatic type conversion
* no need to specify if an option requires arguments (usually)
* assists command line auto-completion

Picocli automatically converts the command line argument to an object of the specified type. We will talk more about how this works below.

Based on the type, picocli "knows" how many arguments the option needs: `boolean` fields don't have an argument, `Collection`, `Map` and array fields can have zero to any number of arguments, and any other type means the options takes a single argument. This can be customized (see `arity`) but most of the time the default is good enough.

Picocli can generate bash completion scripts and JLine Completer candidates, to make your application easier to use for end users. This works best when the options are strongly typed. For example, enums will allow picocli to generate completions with all valid parameters for a given option.

==== Type Conversion
image:https://picocli.info/images/convert.png[width=200]

Picocli converts the option parameter String value to the field type. This is convenient: not only does it save the application from doing this work, it also provides some minimal validation on the user input. If the conversion fails, a `ParameterException` is thrown with a user-friendly error message. We will take another look at error handling later. Picocli comes with built-in converters for many, many types, but you can easily provide a custom type converter.

One example: the Checkstyle `Main` class defines a `-x`, `--exclude-regexp` option that allows uses to specify a number of regular expressions for directories to exclude. With Commons CLI, you need to convert the values to `Pattern` objects in the application:
[source,java]
----
private static List<Pattern> getExclusions(CommandLine commandLine) {
    final List<Pattern> result = new ArrayList<>();

    // ...

    if (commandLine.hasOption(OPTION_X_NAME)) {
        for (String value : commandLine.getOptionValues(OPTION_X_NAME)) {
            result.add(Pattern.compile(value));
        }
    }

    return result;
}
----
By contract, in picocli you would simply declare the option on a `List<Pattern>` (or a `Pattern[]` array) field:
[source,java]
----
/** Option that allows users to specify a regex of paths to exclude. */
@Option(names = {"-x", "--exclude-regexp"},
        description = "Regular expression of directory to exclude from CheckStyle")
private List<Pattern> excludeRegex = new ArrayList<>();
----
Since picocli has a built-in converter for `java.util.regex.Pattern`, this is all that is needed.
Picocli will instantiate and populate the list if one or more `-x` options are specified on the command line.

==== Option Names
image:https://picocli.info/images/name.jpg[width=200]

Finally, Commons CLI supports "short" and "long" options, like `-t` and `--tree`. (Interestingly, the Commons CLI  `DefaultParser` will also accept user input where the `-tree` long option is specified with a single hyphen, even though this is not shown in the usage help message.)

Picocli lets you have any number of options, with any prefix. For example, this is perfectly fine in picocli:

[source,java]
----
@Option(names = {"-t", "-tree", "--tree", "/t", "/tree"}) boolean printAST;
----

==== Positional Parameters
image:https://picocli.info/images/location.jpg[width=200]

A final thing to notice is how positional parameters are handled. In Commons CLI you cannot define positional parameters up front. Instead, its `CommandLine` parse result class has a method `getArgs` that returns the positional parameters as an array of Strings. The Checkstyle `Main` class uses this to create the list of `File` objects to process.

In picocli, positional parameters are first-class citizens, like named options. Not only can they be strongly typed, parameters at different positions can have different types, and each will have a separate description displayed in the usage help message.

For the Checkstyle use case, all that is needed is a list or array of `File` objects, so we declare a field and annotate it with `@picocli.CommandLine.Parameters` to capture the files to process:
[source,java]
----
@Parameters(paramLabel = "file", arity = "1..*", description = "The files to process")
List<File> filesToProcess;
----

The `arity = "1..*"` here means that at least one file must be specified, or picocli will show an error message to the user that this argument is missing, followed by the usage help message.

Unline Commons CLI, picocli's usage help message will show an entry for all positional parameters, using the specified parameter label and description. (If the parameter label is omitted picocli will use the field name in `<` and `>` fish brackets.) We will revisit the usage help message later.

=== Parsing the Command Line Arguments
image:https://picocli.info/images/pipeline.jpg[width=400]

Commons CLI has a `CommandLineParser` interface with a `parse` method that returns a `CommandLine` representing the parse result. The application then calls `CommandLine.hasOption(String)` to see if a flag was set, or `CommandLine.getOptionValue(String)` to get the option value.

Picocli populates the annotated fields as it parses the command line arguments. Picocli's `parse...` methods also return a `ParseResult` that can be queried on what options were specified and what value they had, but most applications don't actually need to use the `ParseResult` class since they can simply inspect the value of the annotated fields.


=== Process the Results
When the parser is done, the application needs to run its business logic, but first there are some things to check:

- Was version info or usage help requested? If so, print out the requested information and quit.
- Was the user input invalid? Print out an error message with the details, print the usage help message and quit.
- Finally run the business logic - and deal with errors thrown by the business logic.

With Commons CLI, this looks something like this:
[source,java]
----
int exitStatus;
try {
    CommandLine commandLine = new DefaultParser().parse(buildOptions(), args);

    // show version and exit if it is requested
    if (commandLine.hasOption(OPTION_VERSION)) {
        System.out.println("Checkstyle version: " + version());
        exitStatus = 0;
    } else if (commandLine.hasOption(OPTION_HELP)) {
        printUsage(System.out);
        exitStatus = 0;
    } else {
        exitStatus = runBusinessLogic();
    }
} catch (ParseException pex) {
    exitStatus = EXIT_WITH_CLI_VIOLATION;
    System.err.println(pex.getMessage());
    printUsage(System.err);
} catch (CheckstyleException ex) {
    exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;
    ex.printStackTrace();
}
System.exit(exitStatus);
----


By making your command implement `Runnable` or `Callable`, you can take advantage of picocli's convenience methods that take care of most of the above, so the application can focus on the business logic. At its simplest, this can look something like this:

[source,java]
----
public class Main implements Callable<Integer> {
    public static void main(String[] args) {
        CommandLine.call(new Main(), args);
    }

    public Integer call() throws CheckstyleException { ...
----

Checkstyle needs to control the exit code, and has some strict internal requirements for error handling, so we ended up not using the convenience methods and kept the parse result processing very similar to what it was with Commons CLI.


== Usage Help Message

A fun bonus is that picocli uses ANSI colors and styles in the usage help message on supported platforms.
Applications can also use ANSI colors and styles in the description or other sections of the usage help message with a simple markup like `@|bg(red) text with red background|@`. See the https://picocli.info/#_usage_help_with_styles_and_colors[relevant section] of the user manual.

For CheckStyle, we kept it to the bare minimum, and the resulting output for CheckStyle looks like this:

image:images/checkstyle-usage.png[]


== Wrapping Up: Quick Tips

To summarize some of the main points when converting an application from Commons CLI to picocli:

* Use annotated fields to define options and positional parameters.
* You can use https://picocli.info/#option-parameters-methods[annotated methods] for options and positional parameters that require more validation than just type conversion.
* Use strong types like `java.nio.file.Path` or `java.util.regex.Pattern` where possible for option and positional parameter fields.
* Use `enum` types for options or positional parameters with a limited set of valid values. Not only will picocli validate the input for you, you can also https://picocli.info/#_show_default_values[show all values] in the usage help message with `@Option(description = "Option x. Valid values: ${COMPLETION-CANDIDATES}")`.
* Be aware that the Commons CLI default parser will recognize both single hyphen and double hyphen long options, even though the usage help message will only show options with double hyphens. You need to decide whether to continue to support this. Use `@Option(names = "-xxx", hidden = true)` to declare long options with a single hyphen if you want to mimic the exact same behaviour as Commons CLI: hidden options picocli https://picocli.info/#_hidden_options_and_parameters[won't be shown] in the usage help message.

== Conclusion

Migrating from Commons CLI to picocli can give end users a more pleasant user experience, and can give developers significant benefits in increased maintainability and potential for future expansion. Migration is a manual process, but is relatively straightforward.

Personally, I was glad to see that the CheckStyle maintainers were happy with the result:

[quote, CheckStyle maintainer Roman Ivanov, (twitter link)]
____
Checkstyle migrated from Apache CLI to @picocli (will be released in 8.15), finally documentation of CLI arguments is now well organized in declarative way in code, and checkstyle's CLI is following CLI best practices.
____


If you like what you saw, please star https://github.com/remkop/picocli[picocli on GitHub] and tell your friends!

