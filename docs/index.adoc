= picocli - a mighty tiny Command Line Interface
Remko Popma <rpopma@apache.org>
v0.3.0, 2017-03-25
:toc: left
:numbered:
:toclevels: 2
:toc-title: Features

A Java command line parsing framework in a single file, so you can include it _in source form_
and your users can run your application without an external dependency.
Produces beautiful and easily tailored usage help messages.

How it works: annotate your class and picocli initializes it from the command line arguments,
converting the input to strongly typed values in the fields of your class.

== Example

[source,java]
----
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import java.io.File;

public class Example {
    @Parameters(description = "Specifies the input file(s).")
    private File[] inputFiles;

    @Option(names = { "-v", "--verbose" }, description = "Be verbose.")
    private boolean verbose = false;

    @Option(names = { "-h", "--help" }, help = true,
            description = "Displays this help message and quits.")
    private boolean helpRequested = false;
    ...
}
----

Then invoke `CommandLine.parse` with the command line parameters and an object you want to initialize.

[source,java]
----
Example app = CommandLine.parse(new Example(), "-v", "inputFile1", "inputFile2");
assert !app.helpRequested;
assert  app.verbose;
assert  app.inputFiles != null && app.inputFiles.length == 2;
----

== Type Conversion
When command line options and parameters are mapped to the annotated fields,
the text value is converted to the type of the annotated field.

=== Built-in Type Converters
Out of the box, picocli can convert strings to:

* any Java primitive type (boolean, int, etc.) #<1>
* the standard Java primitive wrapper types (Boolean, Integer, etc.) #<1>
* java.io.File
* java.math.BigDecimal
* java.math.BigInteger
* java.net.InetAddress
* java.net.URI
* java.net.URL
* java.nio.charset.Charset
* java.sql.Time - value must be in any of the `"HH:mm"`, `"HH:mm:ss"`, `"HH:mm:ss.SSS"`, or `"HH:mm:ss,SSS"` formats
* java.util.Date - value must be in `"yyyy-MM-dd"` format
* java.util.UUID
* java.util.regex.Pattern
* java.lang.String, java.lang.StringBuilder, java.lang.CharSequence

<1> Byte, short, int and long conversion (for both primitives and wrappers) uses the
https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#decode-java.lang.String-[decode] method, so numbers
starting with `0x`, `0X` or `#` are interpreted as hexadecimal numbers, numbers starting with `0` are interpreted
as octal numbers, and otherwise the number is interpreted as a decimal number.

=== Custom Type Converters
Apart from the above, you can register custom converters to handle data types other than the above built-in ones.

Custom converters need to implement the `picocli.CommandLine.ITypeConverter` interface:

[source,java]
----
public interface ITypeConverter<K> {
    /**
     * Converts the specified command line option value to some domain object.
     * @param value the command line option String value
     * @return the resulting domain object
     * @throws Exception an exception detailing what went wrong during the conversion
     */
    K convert(String value) throws Exception;
}
----

Custom type converters can be registered with the `CommandLine.registerConverter(Class<K> cls, ITypeConverter<K> converter)`
method.

Picocli works with Java 5 and higher, but if you can use Java 8, lambdas make it easy to register custom type converters:

[source,java]
----
 commandLine.registerConverter(java.nio.file.Path.class, s -> java.nio.file.Paths.get(s));
 commandLine.registerConverter(java.time.Duration.class, s -> java.time.Duration.parse(s));
----


== Named Options and Positional Parameters ==
Imagine an application that takes some input files and compresses them to an output file.
----
Compress -o outputFile file1 file2 file3
----
The program takes one option (`-o`, the output file) and one or more input files. One way to accomplish this with picoCLI looks like this:

[source, java]
----
import picocli.CommandLine.*;
import java.io.File;

@Usage(programName = "Compress", header = "Compresses the specified input files to an output file")
public class Compress {
    @Parameters(arity = "1..*", description = "one or more files to compress")
    File[] inputFiles;

    @Option(names = {"-o", "--outfile"}, description = "optional output file name. If omitted directory name is used.")
    File outputFile;

    @Option(names = {"-h", "--help"}, help = true, description = "display this help message")
    boolean helpRequested;

    public static void main(String... args) {
        try {
            Compress compress = CommandLine.parse(new Compress(), args);
            if (compress.helpRequested) {
                CommandLine.usage(new Compress(), System.err);
                return;
            }
            doCompress();
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            CommandLine.usage(new Compress(), System.err);
        }
    }

    private void doCompress() { ... } // business logic of the application
}
----

== Command Line Flags and Switches
Boolean options don't need a parameter. If the option name is specified on the command line, the corresponding field is set to `true`:

[source, java]
----
class MyProgram {
    @Option(names = { "-v", "--verbose" }, description = "Verbose mode")
    boolean verbose;
}
----

The boolean field `verbose` will have value `true` when the program is invoked with the "-v" option:
----
CommandLine.parse(new MyProgram(), { "-v", "arg1", "arg2" });
----

=== Explicit Boolean Parameters
It is possible to explicitly specify "true" or "false" as a parameter for a boolean option by defining an explicit <<Arity: Minimum and Maximum Number of Parameters,`arity`>> attribute. A boolean option with `arity = "0..1"` accepts zero to one parameters, `arity = "1"` means the option _must_ have one parameter. For example:

[source, java]
----
class MyProgram {
    @Option(names = "-x", arity = "1", description = "boolean option with 1 mandatory parameter")
    boolean x;

    @Option(names = "-y", arity = "0..1", description = "boolean option with minimum 0 and maximum 1 parameter")
    boolean y;
}
----

The following ways to invoke the program will be accepted (values are not case sensitive):
----
<main> -x true
<main> -x FALSE
<main> -x TRUE -y
<main> -x True -y False
----

But trying to specify the `-x` option without a parameter, or with a value other than "true" or "false" (case insensitive) will result in a `ParameterException`.

== Arity: Minimum and Maximum Number of Parameters
Option fields of type array or `List` (or any class extending `Collection`) will be able to hold multiple values. The `arity` attribute can be used to specify the exact number of required parameters, or a range with a minimum and a maximum number of parameters. The maximum can be a fixed number, or can be `"*"` to denote "any number" of parameters. For example:
[source, java]
----
class MyProgram {
    @Parameters(arity = "3", descriptions = "exactly three Files")
    File[] files;

    @Option(names = "-f", arity = "2..4", description = "two to four floating point numbers")
    double[] doubles;

    @Option(names = "-s", arity = "1..*", description = "at least one string")
    String[] strings;
}
----
A `MissingParameterException` is thrown when fewer than the miminum number of required parameters is specified as command line arguments. Options with an exact number or an exact range will consume up to the maximum number of parameters.

=== Auto-detect New Options
Once the minimum number of parameters is consumed, picoCLI will check for each subsequent command line argument whether it is another parameter, or a new option. For example:

----
<main> -s A B C -f 1.0 2.0 3.0
----
The above command line arguments will be parsed as three parameters for the `-s` option, followed by three parameters for the `-f` option.

=== Ambiguous Input
Positional parameters do not have an option name, and the below example command line arguments will be parsed as six parameters for the `-s` option, not as three strings and three files:
----
<main> -s A B C file1 file2 file3
----

Users can disambiguate the input by specifying a double dash (`--`) after the option parameters.
The argument `--` is interpreted as a delimiter indicating the end of options. Any following arguments are treated as positional parameters. For example, the following command line arguments will be parsed as three strings and three files:
----
<main> -s A B C -- file1 file2 file3
----

== Default Arity: Number of Parameters Depends on Option Type
Most of the time options don't need to define their arity explicitly. When the arity is not specified, the implicit arity of the option depends on the field's type:

* Boolean fields: `"0"`. By default no parameters are required or expected.
* Single-valued types (primitive fields, Number fields, String, File etc): `"1"`. By default option fields with these types expect a single value.
* Multi-valued types (arrays or classes extending `Collection`): `"0..*"`. By default option fields with this type have no mandatory parameters but accept any number of parameters.

== Required Options
Options can be marked `required` to make it mandatory for the user to specify them on the command line. When a required option is not specified, a `MissingParameterException` is thrown from the `parse` method. For example:
[source, java]
----
class MyProgram {
    @Parameters(arity = "3", descriptions = "exactly three Files")
    File[] files;

    @Option(names = "-x", description = "optional switch")
    boolean x;

    @Option(names = "-y", required = true, description = "mandatory switch")
    boolean y;

    @Option(names = "-n", required = true, description = "mandatory number")
    int number;
}
----
The following command line arguments would result in an exception complaining that `y` and `number` are missing:
----
CommandLine.parse(new MyProgram(), "-x file1 file2 file3")
----
The following command line arguments would be accepted:
----
CommandLine.parse(new MyProgram(), "-x -y -n 123 file1 file2 file3")
----


// TODO document that if arity>1 and args="-opt=val1 val2", arity overrules the "=": both values are assigned


== Options with Parameters
== parameters are strongly typed
== built-in type converters
== registering custom type converters
== option short form

== Clustered Short Options
Single-character options preceded with a '-', like `-v` or `-r`, can be grouped, so `-vxr` is equivalent to `-v -x -r`.

// TODO ambiguous short options: ambiguity with the -f FILE and -fFILE notation.
// TODO ambiguous options: writing --input ARG (as opposed to --input=ARG) is ambiguous,


== Download

NOTE: Here is the source. Copy and paste it into a file called `CommandLine.java`, add it to your project, and enjoy!

[source,java]
----
include::../src/main/java/picocli/CommandLine.java[]
----