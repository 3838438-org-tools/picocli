= Quick Guide
//:author: Remko Popma
//:email: rpopma@apache.org
:revnumber: 3.3.1-SNAPSHOT
:revdate: 2018-07-14
:toc: left
:numbered:
:toclevels: 2
:toc-title: Features
:source-highlighter: coderay
:icons: font
:imagesdir: images

The user manual for the latest release is at http://picocli.info[http://picocli.info].

== What is picocli
Picocli is a Java library and mini-framework for creating command line applications with almost no code.

It supports a variety of command line syntax styles including POSIX, GNU, MS-DOS and more.
It generates highly customizable usage help messages with <<ANSI Colors and Styles,ANSI colors and styles>>.
Picocli-based applications can have link:autocomplete.html[command line TAB completion] showing available options, option parameters and subcommands, for any level of nested subcommands.

.Example usage help message
image:ExampleUsageANSI.png[Screenshot of usage help with Ansi codes enabled]

== How to use it
The easiest is to create a class and annotate its fields or methods with `@Option` or `@Parameters` to declare what options and positional parameters your application expects.
While parsing the command line, picocli will initialize these fields based on the command line arguments.
If your class implements `Runnable` or `Callable`, you can let picocli kick off your application after parsing is successfully completed.

NOTE: For applications that cannot use the annotations, there is also a programmatic API for defining what options and positional parameters to expect, and a programmatic API for handling parse results. The programmatic API is not covered in this Quick Guide.

=== Example
Here is a small example application that uses the `CommandLine.call` <<Less Boilerplate,convenience method>>
to do parsing and error handling in one line of code. The <<Fully Automatic Help,mixinStandardHelpOptions>> attribute
adds usage help and version help options your application.

.Example `Callable` application
[[CheckSum-application]]
[source,java]
----
@Command(description = "Prints the checksum (MD5 by default) of a file to STDOUT.",
         name = "checksum", mixinStandardHelpOptions = true, version = "checksum 3.0")
class CheckSum implements Callable<Void> {

    @Parameters(index = "0", description = "The file whose checksum to calculate.")
    private File file;

    @Option(names = {"-a", "--algorithm"}, description = "MD5, SHA-1, SHA-256, ...")
    private String algorithm = "SHA-1";

    public static void main(String[] args) throws Exception {
        CommandLine.call(new CheckSum(), args);
    }

    @Override
    public Void call() throws Exception {
        byte[] fileContents = Files.readAllBytes(file.toPath());
        byte[] digest = MessageDigest.getInstance(algorithm).digest(fileContents);
        System.out.println(javax.xml.bind.DatatypeConverter.printHexBinary(digest));
        return null;
    }
}
----

== Options and Parameters
Command line arguments can be separated into _options_  and _positional parameters_.
Options have a name, positional parameters are usually the values that follow the options,
but they may be mixed.

image:http://picocli.info/images/OptionsAndParameters2.png[Example command with annotated @Option and @Parameters]

Picocli has separate annotations for options and positional parameters.

=== Options
An option must have one or more `names`.
Option names commonly start with `-` or `--`, but picocli lets you use any option name you want.


The below example shows options with one or more names, options that take an option parameter, and a <<Help Options,help>> option.
[source,java]
----
class Tar {
    @Option(names = "-c", description = "create a new archive")
    boolean create;

    @Option(names = { "-f", "--file" }, paramLabel = "ARCHIVE", description = "the archive file")
    File archive;

    @Parameters(paramLabel = "FILE", description = "one ore more files to archive")
    File[] files;

    @Option(names = { "-h", "--help" }, usageHelp = true, description = "display a help message")
    private boolean helpRequested;
}
----
Picocli matches the option names to set the field values.
[source,java]
----
String[] args = { "-c", "--file", "result.tar", "file1.txt", "file2.txt" };
Tar tar = new Tar();
new CommandLine(tar).parse(args);

assert !tar.helpRequested;
assert  tar.create;
assert  tar.archive.equals(new File("result.tar"));
assert  Arrays.equals(tar.files, new File[] {new File("file1.txt"), new File("file2.txt")});
----

Picocli supports http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02[POSIX clustered short options]:
one or more single-character options without option-arguments, followed by at most one option with an option-argument, can be grouped behind one '`-`' dash.

For example, for the `Tar` example above, the following command line invocations are equivalent:

.Example commands with clustered short options
----
tar -c -f result.tar f1.txt f2.txt
tar -cf result.tar f1.txt f2.txt
tar -cfresult.tar f1.txt f2.txt
----

=== Positional Parameters
Any command line arguments that are not subcommands, options or option parameters are interpreted as positional parameters.

Use the (zero-based) `index` attribute to specify exactly which parameters to capture.
Omitting the `index` attribute means the field captures _all_ positional parameters.
Array or collection fields can capture multiple values.

The `index` attribute accepts _range_ values, so an annotation like `@Parameters(index="2..4")` captures the arguments at index 2, 3 and 4. Range values can be _open-ended_. For example, `@Parameters(index="3..*")` captures all arguments from index 3 and up.

For example:

[source,java]
----
class PositionalDemo {
    @Parameters(index = "0")    InetAddress host;
    @Parameters(index = "1")    int port;
    @Parameters(index = "2..*") List<File> files;
}
----

Picocli initializes fields with the values at the specified index in the arguments array.
[source,java]
----
String[] args = { "localhost", "12345", "file1.txt", "file2.txt" };
PositionalDemo params = CommandLine.populateCommand(new PositionalDemo(), args);

assert params.host.getHostName().equals("localhost");
assert params.port == 12345;
assert params.files.equals(Arrays.asList(new File("file1.txt"), new File("file2.txt")));
----

The user manual has more details about options and positional parameters, as well as the http://picocli.info/#_double_dash_code_code[`--` delimiter] and parameter files (http://picocli.info/#AtFiles[`@`-files]).

== Strongly Typed Everything
When command line options and positional parameters are mapped to the annotated fields,
the text value is converted to the type of the annotated field.

=== Type Conversion
Out of the box, picocli can convert command line argument strings to a number of common data types.

See the manual for the full list of link:http://picocli.info/#_built_in_types[built-in types], but in general all primitive types and their Object equivalent,
any enum, and common classes like `File`, `Date`, `URL`, `BigDecimal`, regex `Pattern` etc. can be used as is.
Applications running on Java 7 can use `Path`, and on Java 8 the new `java.time` classes can be used.

You can also use a link:http://picocli.info/#_custom_type_converters[custom type converter] to handle data types other than the above built-in ones.

=== Collections and Maps
If an option or positional parameter can have multiple values, the field type must be an array, a `Collection` or a `Map`.
Any `Collection` subclass like `List`, `Set`, or `Queue` can be used.

A common requirement is to have options with key-value pairs similar to Java's system properties, like `-Dkey=value`.
To achieve this, all you need to do is use a `Map` field.

`Map` fields may have any type for their key and value
as long as a <<Strongly Typed Everything,type converter>> is registered for both the key and the value type.
Key and value types are inferred from the map's generic type parameters.
For example:

[source,java]
----
class MapDemo {
    @Option(names = {"-u", "--timeUnit"});
    Map<java.util.concurrent.TimeUnit, Long> timeout;
}
----

The following command line would result in four key-value entries in the map:

[source,bash]
----
<command> -uDAYS=3 -u HOURS=23 -u=MINUTES=59 --timeUnit=SECONDS=13
----


== Required Arguments
=== Required Options
Options can be marked `required` to make it mandatory for the user to specify them on the command line. When a required option is not specified, a `MissingParameterException` is thrown from the `parse` method. For example:
[source, java]
----
@Option(names = "-n", required = true, description = "mandatory number")
int number;
----

=== Required Parameters
Use the `arity` attribute to make `@Parameters` mandatory:
[source, java]
----
@Parameters(arity = "1..*", descriptions = "at least one File")
List<File> files;
----

== Multiple Values
Multi-valued options and positional parameters are annotated fields that can capture multiple values from the command line.

=== Repeated Options
The simplest way to create a multi-valued option is to declare an annotated field whose type is an array, collection or a map.

[source,java]
----
@Option(names = "-option")
int[] values;
----
Users may specify the same option multiple times. For example:
----
<command> -option 111 -option 222 -option 333
----
Each value is appended to the array or collection.

=== Split Regex
Options and parameters may also specify a `split` regular expression used to split each option parameter into smaller substrings.
Each of these substrings is converted to the type of the collection or array. See <<Collections and Maps>>.
[source,java]
----
@Option(names = "-option", split = ",")
int[] values;
----
A single command line argument like the following will be split up and three `int` values are added to the array:
----
-option 111,222,333
----


=== Arity
Sometimes you want to define an option that requires more than one option parameter _for each option occurrence_ on the command line.

The `arity` attribute lets you control exactly how many parameters to consume for each option occurrence.

The `arity` attribute can specify an exact number of required parameters, or a _range_ with a minimum and a maximum number of parameters.
The maximum can be an exact upper bound, or it can be `"*"` to denote _any number_ of parameters. For example:
[source, java]
----
class ArityDemo {
    @Parameters(arity = "1..3", descriptions = "one to three Files")
    File[] files;

    @Option(names = "-f", arity = "2", description = "exactly two floating point numbers")
    double[] doubles;

    @Option(names = "-s", arity = "1..*", description = "at least one string")
    String[] strings;
}
----
A `MissingParameterException` is thrown when fewer than the miminum number of parameters is specified on the command line.


=== Default Arity
If no `arity` is specified, the number of parameters depends on the field's type.
The user manual has more details on http://picocli.info/#_default_arity[arity].

== Help Options

=== Mixin Standard Help Options
When the `mixinStandardHelpOptions` command attribute is set to `true`, picocli adds a <<Mixins,mixin>> to the
command that adds <<Help Options,`usageHelp`>> and <<Help Options,`versionHelp`>> options to the command. For example:

[source,java]
----
@Command(mixinStandardHelpOptions = true, version = "auto help demo - picocli 3.0")
class AutoHelpDemo implements Runnable {

    @Option(names = "--option", description = "Some option.")
    String option;

    @Override public void run() { ... }
}
----

The usage help message for the above example looks like this:
----
Usage: <main class> [-hV] [--option=<option>]
      --option=<option>   Some option.
  -h, --help              Show this help message and exit.
  -V, --version           Print version information and exit.
----

=== Custom Help Options
Applications can define custom help options by setting attribute `versionHelp = true`, `usageHelp = true` or `help = true`.
If one of the arguments specified on the command line is a "help" option, picocli will not throw a `MissingParameterException` when required options are missing.

For example:

[source,java]
----
@Option(names = {"-V", "--version"}, versionHelp = true, description = "display version info")
boolean versionInfoRequested;

@Option(names = {"-h", "--help"}, usageHelp = true, description = "display this help message")
boolean usageHelpRequested;
----
Use these attributes for options that request the usage help message or version information to be shown on the console.

[source,java]
----
App app = CommandLine.populateCommand(new App(), args);
if (app.usageHelpRequested) {
   CommandLine.usage(new App(), System.out);
   return;
}
----

The `CommandLine` class offers two methods that allow external components to detect whether
usage help or version information was requested (without inspecting the annotated domain object):

* `CommandLine.isUsageHelpRequested()` returns `true` if the parser matched an option annotated with `usageHelp=true`
* `CommandLine.isVersionHelpRequested()` returns `true` if the parser matched an option annotated with `versionHelp=true`

[source,java]
----
CommandLine commandLine = new CommandLine(new App());
commandLine.parse(args);
if (commandLine.isUsageHelpRequested()) {
   commandLine.usage(System.out);
   return;
} else if (commandLine.isVersionHelpRequested()) {
   commandLine.printVersionHelp(System.out);
   return;
}
// ... run App's business logic
----
See also <<Printing Help Automatically>>.
