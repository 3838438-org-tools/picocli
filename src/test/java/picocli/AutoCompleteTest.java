/*
   Copyright 2017 Remko Popma

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
package picocli;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.URL;
import java.util.concurrent.TimeUnit;

import org.junit.Test;

import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import static org.junit.Assert.*;

/**
 * Tests the scripts generated by AutoComplete.
 */
// http://hayne.net/MacDev/Notes/unixFAQ.html#shellStartup
// https://apple.stackexchange.com/a/13019
public class AutoCompleteTest {
    @Test
    public void basic() throws Exception {
        class App {
            @Option(names = {"-u", "--timeUnit"}) private TimeUnit timeUnit;
            @Option(names = {"-t", "--timeout"}) private long timeout;
        }
        String script = AutoComplete.bash("basicExample", new CommandLine(new App()));
        String expected = loadTextFromClasspath("/basic.bash");
        assertEquals(expected, script);
    }
    @Test
    public void nestedSubcommands() throws Exception {
        class TopLevel {
            @Option(names = {"-V", "--version"}, help = true) boolean versionRequested;
            @Option(names = {"-h", "--help"}, help = true) boolean helpRequested;
        }
        @Command(description = "First level subcommand 1")
        class Sub1 {
            @Option(names = "--num", description = "a number") double number;
            @Option(names = "--str", description = "a String") String str;
        }
        @Command(description = "First level subcommand 2")
        class Sub2 {
            @Option(names = "--num2", description = "another number") int number2;
            @Option(names = {"--directory", "-d"}, description = "a directory") File directory;
        }
        @Command(description = "Second level sub-subcommand 1")
        class Sub2Child1 {
            @Option(names = {"-h", "--host"}, description = "a host") InetAddress host;
        }
        @Command(description = "Second level sub-subcommand 2")
        class Sub2Child2 {
            @Option(names = {"-u", "--timeUnit"}) private TimeUnit timeUnit;
            @Option(names = {"-t", "--timeout"}) private long timeout;
        }
        CommandLine hierarchy = new CommandLine(new TopLevel())
                .addSubcommand("sub1", new Sub1())
                .addSubcommand("sub2", new CommandLine(new Sub2())
                        .addSubcommand("subsub1", new Sub2Child1())
                        .addSubcommand("subsub2", new Sub2Child2())
                );
        String script = AutoComplete.bash("hierarchy", hierarchy);
        String expected = loadTextFromClasspath("/nestedSubcommands.bash");
        assertEquals(expected, script);
    }

    private static String loadTextFromClasspath(String path) {
        URL url = AutoCompleteTest.class.getResource(path);
        if (url == null) { throw new IllegalArgumentException("Could not find '" + path + "' in classpath."); }
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuilder result = new StringBuilder(512);
            char[] buff = new char[4096];
            int read = 0;
            do {
                result.append(buff, 0, read);
                read = reader.read(buff);
            } while (read >= 0);
            return result.toString();
        } catch (IOException ex) {
            throw new IllegalStateException("Could not read " + url + " for '" + path + "':", ex);
        } finally {
            if (reader != null) { try { reader.close(); } catch (IOException e) { /* ignore */ } }
        }
    }

}
